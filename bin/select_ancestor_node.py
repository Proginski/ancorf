#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
This program reads a newick tree generated by Prank (the tree has ancestor/internal nodes).
It also reads a FASTA where the ids are genomes names (they correspond to the tree leaves), and the descriptions (after the id) are either "focal", "CDS", or "genome".
Then it selects the ancestor node required by the user, typically the mrca of the focal genome and its closest outgroup neighbor(s).
"""


import argparse
import dendropy
from Bio import SeqIO

def main():
    parser = argparse.ArgumentParser(description='Find MRCA of focal genome and closest outgroup genome.')
    parser.add_argument('alignment_tree_file', help='The Newick tree file of the genomes.')
    parser.add_argument('alignment_fasta_file', help='The FASTA file with genome tags.')
    parser.add_argument('prank_tree_file', help='The Newick tree file from Prank.')
    parser.add_argument('prank_fasta_file', help='The FASTA file from Prank.')
    parser.add_argument('-o', '--output_fasta', help='The FASTA file with the ancestor node.')
    args = parser.parse_args()

    tree = dendropy.Tree.get(path=args.alignment_tree_file,
        schema="newick",
        rooting='force-rooted')

    focal = None
    genomes_names = []
    cds_names = []
    for record in SeqIO.parse(args.alignment_fasta_file, "fasta"):
        tag = record.description.split()[1]
        if tag == "focal":
            focal = record.id
        elif tag == "genome":
            genomes_names.append(record.id)
        elif tag == "CDS":
            cds_names.append(record.id)


    #### TREE INFORMATION ####
    # Open the tree file to order the neighbors with respect to the focal genome.
    # To do so, get the distance between the focal genome and each neighbor.
    # Two of more neighbors of the same "outgroup" should have the same distance to the focal genome.
    # The classical 'time of divergence' may lead to small differences if branches are not of equal length.
    # For example, Pan paniscus and Pan troglodytes form a possible "outgroup" in the human-and-its-neighbors tree,
    # but their calculated time of divergence with human may not be the same.
    # So just get the rank of the most recent common ancestor (MRCA) node.

    # Get the list of taxon labels (e.g. genome names)
    taxon_labels = [ tree.taxon_namespace[i].label for i in range(0,len(tree.taxon_namespace)) ]

    # Set every edge length to 1. By doing so, we are sure the calc_node_root_distances can be used
    # Besides, we do not care about the actual value of each edge length in this case.
    for node in tree.preorder_node_iter():
        node.edge.length = 1

    # Adds attribute “root_distance” to each node, with value set to the sum of 
    # edge lengths from the node to the root. Returns list of distances. 
    tree.calc_node_root_distances(return_leaf_distances_only=False) 

    # For each genome in taxon_labels, get its most recent common ancestor with 
    # the focal genome (= a node), and get its distance to the tree root.
    root_distance = { name:int(tree.mrca(taxon_labels=[focal, name]).root_distance) for name in taxon_labels if name != focal }
    root_distance[focal]=max(root_distance.values()) +1

    # Reverse the dictionary to make further comparisons more intuitive (focal is 0, its closest neighbor is 1, etc.)
    max_distance = max(root_distance.values())
    focal_distance = { genome: max_distance - root_distance[genome] for genome in root_distance }

    # List of genomes sorted by distance to the focal genome
    sorted_genomes = sorted(focal_distance, key=focal_distance.get)

    # # Get the maximum distance for a CDS match
    # # Genome matches that are farther than this distance are "outgroup" matches
    # CDS_distances = [focal_distance[name] for name in sorted_genomes if name in cds_names]
    # genome_distances = [focal_distance[name] for name in sorted_genomes if name in genomes_names]

    # if len(CDS_distances) > 0:
    #     max_CDS_distance = max(CDS_distances)
    # else:
    #     max_CDS_distance = 0
    # outgroup_distances = [distance for distance in genome_distances if distance > max_CDS_distance]
    # if len(outgroup_distances) > 0:
    #     min_outgroup_distance = min(outgroup_distances)
    #     first_outgroup_names = [name for name in sorted_genomes if name in genomes_names and focal_distance[name] == min_outgroup_distance]
    # else:
    #     print("No outgroup distances found, using max distance among CDS or genome distances.")
    #     min_outgroup_distance = max([distance for distance in genome_distances + CDS_distances])
    #     print(f"Using max distance {min_outgroup_distance} as the minimum outgroup distance.")
    #     first_outgroup_names = [name for name in sorted_genomes if focal_distance[name] == min_outgroup_distance]
    # print(f"The closest outgroup genome(s) to {focal} is/are {first_outgroup_names}.")

    hit_distances = [ focal_distance[name] for name in sorted_genomes if name in genomes_names or name in cds_names ]
    penultimate_hit_distance = sorted(hit_distances)[-2] if len(hit_distances) > 1 else sorted(hit_distances)[0]
    first_outgroup_names = [ name for name in sorted_genomes if focal_distance[name] == penultimate_hit_distance ]

    gene_tree = dendropy.Tree.get(path=args.prank_tree_file,
        schema="newick",
        rooting='force-rooted')
    ancestor_node = gene_tree.mrca(taxon_labels=[focal, first_outgroup_names[0]]).label

    print(f"The ancestor node of {focal} and its closest outgroup genome(s) is {ancestor_node}.")

    with open(args.prank_fasta_file, "r") as input_handle:
        for record in SeqIO.parse(input_handle, "fasta"):
            if record.id == ancestor_node:
                with open(args.output_fasta, "w") as output_handle:
                    SeqIO.write(record, output_handle, "fasta")
                break


if __name__ == '__main__':
    main()